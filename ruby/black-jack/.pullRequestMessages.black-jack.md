не стал пока проверять работу приложения
давай начнем со структуры
во-первых стоит полностью разделить логику и интерфейс

класс логики (можно называть его контроллер, рантайм) должен общаться с интерфейсом примерно так:

def some_action
  @interface.show_some_menu
  @interface.ask_some_question
  answer = @interface.receive_some_answer
  some_other_action(answer)
end
(соответственно интерфейс можно к примеру передать в класс рантайма при его инициализации)

методы интерфейса:

либо метод с puts
либо метод с gets
либо вызов метода другого интерфейса или своего метода
может быть метод возвращающий какую-то строку или коллекцию строк для вывода
и по сути все... больше в этом классе не должно происходить ничего
методы интерфейса могут выглядеть так:

def show_some_menu
  puts "Some menu"
  puts "1 - go somewhere"
  puts "2 - go elsewhere"
  puts "0 - exit"
end

def ask_some_question
  gets.chomp
end
главный плюс такого подхода и одновременно ориентир, для правильного понимания того, как нужно писать интерфейс и его взаимодействие с контроллером:
вместо интерфейса командной строки можно в любой момент написать другой интерфейс, который будет к примеру работать не в командной строке, а отправлять запросы посредством http протокола... (лишь бы названия методов, т.е. интерфейс класса совпадал), а логика должна спокойно продолжить работу не обращая внимания на смену интерфейса...

во-вторых, чтобы приложение больше соответствовало ООП принципам стоит выделить больше классов сущностей и оперировать с ними, а не с более низкоуровневыми объектами, как у тебя (массивы, хеши, строки)

у тебя уже есть Банк и Плеер
как минимум стоит добавить классы Карта (хранит аттрибуты каждой отдельно взятой карты, в том числе валидирует их при инициализации), Колода - хранит коллекцию объектов класса Карта созданную по определенному алгоритму, имеет свои методы, к примеру "перемешать", "выдать карту" и т.п.
будет правильно также добавить класс Рука, который бы хранил коллекцию карт, принадлежащих игроку в ходе очередного раунда
прямое хранение денег в переменной в классе Плеер стоит заменить на инициализацию в этом классе переменной храняшей объект класса Банк - так можно добиться изолиции финансовых операций - пусть методы работы с деньгами все сконцентрируются в этом классе, а класс Плеер пусть занимается взаимодействием с рантаймом, банком и рукой

попробуй в таком направлении изменить программу, будут вопросы - пиши




интересное меню - состоит из одного пункта ))

Ваши очки
17
Дилер выиграл!
Введите
1 - Сыграть ещё раз

при вводе любой другой цифры повторно выводит результаты последнего сыгранного раунда и снова выводит это же меню из одного пункта - завершение игры невозможно )

с подсчетом тузов непорядок:

Ваши карты
D<> T+ K+ 
Ваши очки
31
а здесь

Ваши карты
T<> K+ T<3 
Ваши очки
22
не 22, а 12
здесь должно быть 21 очко

интересный момент
есть файл main но в нем класс BlackJack
и есть файл black_jack, но в нем содержимое очень похоже на то, что ожидаешь от файла main

[*(2..10).to_a, 'J', 'D', 'K', 'T'].each do |i|
      ['+', '<3', '^', '<>'].each do |j|
Comment on lines 38 to 39
Beta Send feedback
   @max-underthesun
max-underthesun on 2 Oct
масти и номиналы лучше хранить в константах и здесь обращаться к константам
   @max-underthesun
max-underthesun on 2 Oct
соответственно эти константы мастей и номиналов лучше держать в классе карты (где и проверять вхождение аттрибутов объекта в эти коллекции)

def count_points(cards)
   @max-underthesun
max-underthesun on 2 Oct
этот метод вряд ли относится к данному классу (по сути этот класс - это колода)
подсчетом очков лучше передать в класс Hand

def setup
    @diler = Player.new('Diler', 100)
    puts 'Введите ваше имя'
    name = gets.chomp
    @player = Player.new(name, 100)
    @interface = Interface.new
    @dealer = Player.new('Dealer', Bank.new(100))
    name = @interface.name
    @player = Player.new(name, Bank.new(100))
    @bank = Bank.new(0)
    deal_cards
  end
Comment on lines 15 to 22
Beta Send feedback
   @max-underthesun
max-underthesun on 2 Oct
подобный набор действий - инициализация инстанс-переменных - это как раз то, чем занимается метод initialize
   @max-underthesun
max-underthesun on 2 Oct
кроме конечно вызова deal_cards

dealer_hand.add_card(@cards.take_card)
    @dealer.add_hand(dealer_hand)

     @bank.add_cash(@dealer.cash.take_cash(10) + @player.cash.take_cash(10))
   @max-underthesun
max-underthesun on 2 Oct  • 
edited 
по сути в одной строке происходит несколько действий - списываются деньги с каждого из игроков, деньги списанные с игроков суммируются, сумма списанная с игроков записывается в банк
у этого класса получается слишком много знаний о других классах (о классах игроков он знает что у них есть аттрибут, в котром хранится объект, который откликается на метод take_cash)
в коде присутствуют "магические цифры" (10)
по 3-му пункту - правильно подобные цифры выносить в константы, в соответствующем классе (здесь видимо логично будет в классе Bank инициализировать константу BET, к примеру)

чтобы уменьшить сложность в рантайме и изолировать класс БлекДжек от знаний внутреннего устройства игроков лучше здесь реализовать как-то например в таком стиле:

  current_round_bank = @dealer.take_bet + @player.take_bet
  @bank.take_cash_from_players(current_round_bank)
соответсвенно в классе Player надо будет примерно так реализовать:

def take_bet
  @bank.take_bet
end
по сути - делегировать метод банку
ну и уже пусть банк знает о таких подробностях, как размер ставки:

def take_bet
  take_cash(BET)
end
реализация в подобном стиле несколько более многословная, но имеет своим намерением большую изолированность классов, что хорошо

наверное, если подумать, можно еще более правильные варианты сконструировать - этот вариант просто для примера "в какую сторону стоит рефакторить"
в этом классе есть еще несколько точек, где код слишком много знает о других классах - как правило это считается минусом дизайна

вот это не совсем правильно:

Конец игры!
Карты дилера
JACK^ 9+ 6^ 
Очки дилера
25
Ваши карты
DAME+ 9<3 3^ 
Ваши очки
22
Вы выиграли!
если у игрока перебор, то дилер даже не берет 3-ю карту и игрок на переборе всегда проигрывает

вот тут тоже не верно:

Ваши карты
JACK^ T<> 
Ваши очки
11
почему 11? это же 21
или вот:

Ваши карты
T<3 T<> 
Ваши очки
2
должно быть 12 очков
а здесь

Карты дилера
T<3 T^ T+ 
Очки дилера
3
13 а не 3

[*(2..10).to_a, 'J', 'D', 'K', 'T'].each do |i|
      ['+', '<3', '^', '<>'].each do |j|
        @cards << "#{i}#{j}"
    [TWO, THREE, FOUR, FIVE, SIX, SEVEN, EIGHT, NINE, TEN, DAME, KING, JACK, ACE].each do |i|
   @max-underthesun
max-underthesun on 2 Oct
писать отдельную константу для кждого номинал - это скорее перебор
я в прошлый раз предложил хранить в константе коллекцию
т.е. вот это все: [*(2..10).to_a, 'J', 'D', 'K', 'T'] я предлагал положить в константу, а не каждый номинал в отдельную
и посмотри второй комментарий по поводу того где я прелагал объявлять эти константы


   def run
    deal_cards
   @max-underthesun
max-underthesun on 2 Oct
я не уверен в необходимости метода, который только вызывает другой метод... ну ладно, может быть правда нужно

@name = name
    @cards = []
    @cash = cash
   @max-underthesun
max-underthesun on 2 Oct
может честно назвать @bank ? чтобы понятней было при чтении

class Cards
  CARDS = [*(2..10).to_a, 'JACK', 'DAME', 'KING', 'T']
  COLORS = ['^', '+', '<3', '<>']
   @max-underthesun
max-underthesun on 3 Oct
здесь конечно же не нужно дублировать константы
это точно неверно

['+', '<3', '^', '<>'].each do |j|
        @cards << "#{i}#{j}"
    CARDS.each do |i|
      COLORS.each do |j|
   @max-underthesun
max-underthesun on 3 Oct
просто ссылайся тут на константы класса Card

def act_dealer
    act_end_game if game_end?
    dealer_points = @dealer.hand.count_points
    if dealer_points < 17
      card = @cards.take_card
      @dealer.hand.add_card(card)
    end
    act_player
  end
Comment on lines +57 to +65
Beta Send feedback
   @max-underthesun
max-underthesun on 3 Oct
в методе act_player идет обращение к интерфейсу и пользователь принимает решени о следующем ходе
по хорошему вот в этом методе не должно приниматься решение о том ходить дилеру или нет
более правильная реализация - создать подкласс класса Player - Dealer и в этом подклассе прописать логику принятия решений дилером
далее в классе рантайма обращаться именно к методам объекта "дилер", чтобы "дилер принимал решения"
это будет более верно, нежели данную логику оставлять в классе BlackJack