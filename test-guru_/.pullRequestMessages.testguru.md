Вариант
Время
Оценка
Comment on lines 8 to 10
Beta Send feedback
   @max-underthesun
max-underthesun on 4 Oct
последние 3 не очень понял о чем )

сценария использования приложения примерно такой:

Пользователь заходит на сайт
он выбирает Тест
Тест состоит из Вопросов
на каждый Вопрос есть несколько Ответов
Пользователь выбирает один или несколько Ответов, чтобы ответить на каждый из Вопросов
Результат тестирования сохраняется

 </div>
    <p>ТестГуру - это сайт для создания и прохождения тестов.</p>
    <p>Здесь вы можете создавать тесты в качестве администратора и проходить их в качестве клиента.</p>
    <p><a href="www.thinknetica.com">Онлайн-школа Thinknetica</a></p>
   @max-underthesun
max-underthesun on 4 Oct
ссылки на сторонние ресурсы правильно открывать в новом окне

# Version of your assets, change this if you want to expire all your assets.
Rails.application.config.assets.version = '1.0'
Rails.application.config.assets.version = '1.0.0'
   @max-underthesun
max-underthesun on 4 Oct
вот документация, вот на SO вопрос...
другими словами - ты здесь задаешь именно версию ассетов, а не версию приложения

ТЗ: "Добавьте Initializer с версией приложения" - нужно добавить свой инишиалайзер (свой файл)
   @max-underthesun
max-underthesun on 4 Oct
не уверен, что версия имеет отношение к config.assets
лучше использовать константу
ты здесь хранишь некое значение, которое в процессе рантайма не предполагает изменений, а такую функцию принято в большинстве случаев поручать именно константам
   @max-underthesun
max-underthesun on 4 Oct
с версией ты погорячился
посомотри еще раз ресурс, где объясняются принципы
первая цифра - это релиз, т.е. рабочая версия приложения
вряд ли первый же комит можно сразу объявлять релизом

VERSION = '0.0.1'
   @max-underthesun
max-underthesun on 4 Oct
если посмотреть еще раз документацию, то там написано, что последний разряд предназначен для патчей, фиксов
другими словами текущие итерации работы между пулл-реквестами правильно обозначать во втором разряде, первый - для релизов, по сути он станет 1, когда учебный проект завершится
последний - для мини-фиксов, т.е. к примеру работа над ошибками может изменить последний разряд, если мы про текущий проект будем говорить
   @max-underthesun
max-underthesun on 4 Oct
"мутабельные" объекты (строки, хэши, массивы) рекомендуется freeze-ить, чтобы они были неизменяемыми
в противном случае константу, ссылающуюся на "мутабельный" объект, можно изменить: VERSION << '3.14..'

VERSION = '0.0.1'

 Rails.application.config.version = VERSION
   @max-underthesun
max-underthesun on 4 Oct
это конечно допустимо, но выбивается из всей экосистемы Ruby
в любом геме есть константа VERSION

более стандартный вариант можно загуглить ))
к примеру запрос в гугле вида "where to set rails application version" выводит список ответов на этот вопрос на СО
первый в списке вопрос в самом вопросе и в ответе содержит вполне рабочие предложения по этому поводу




class AddDetailsToAnswers < ActiveRecord::Migration[6.0]
  def change
    change_column_default(:answers, :correct, true)
   @max-underthesun
max-underthesun on 6 Oct
в документации рекомендуют записывать миграцию смены "дефолта" вот так:

change_column_default :products, :approved, from: true, to: false
варианты с использованием change_column или с change_column_default, но без from: и to: работают, но их нельзя откатить (они irreversible) - лучше все миграции (по возможности) делать "откатываемыми"

class AddDetailsToTests < ActiveRecord::Migration[6.0]
  def change
    change_column_null(:tests, :title, false)
    change_column_default(:tests, :level, 0)
   @max-underthesun
max-underthesun on 6 Oct
когда будешь править назначения дефолта учти, что лучше сначала назначать дефолт, а потом запрещать "нил"
можно получить проблемы с откатом миграций на этом моменте, потому что первой будет откатываться миграция с дефолтами и база на откате попытается поставить "нил" в поле, но "нил" запрещен предыдущей миграцией, которая еще не откатилась

class AddDetailsToQuestions < ActiveRecord::Migration[6.0]
  def change
    change_column_null(:questions, :title, false)
    add_reference :questions, :answer
   @max-underthesun
max-underthesun on 6 Oct
более верно будет ссылку на вопрос добавить в таблицу ответов
именно ответ привязан к вопросу, а не наоборот
   @max-underthesun
max-underthesun on 6 Oct
кроме того стоит добавить опцию foreign_key: true, чтобы наложить ограничение foreign_key на поле
вот такой вариант:

t.references :category
создаст поле и индекс
запрос SQL:

CREATE TABLE "tests" (
"id" bigserial primary key,
"category_id" bigint
)
CREATE  INDEX  "index_tests_on_category_id" ON "tests"  ("category_id")
чтобы добавить FOREIGN KEY constraint нужно миграцию записать так:

t.references :category, foreign_key: true
в этом случае сгенерированный запрос SQL будет такого вида:

CREATE TABLE "tests" (
"id" bigserial primary key,
"category_id" bigint,
CONSTRAINT "fk_rails_2f2557d9f5" FOREIGN KEY ("category_id") REFERENCES "categories" ("id")
)
CREATE  INDEX  "index_tests_on_category_id" ON "tests"  ("category_id")
   @max-underthesun
max-underthesun on 6 Oct
подумай
хорошо бы и в другие таблицы добавить внешние ключи

class AddDetailsToAnswers < ActiveRecord::Migration[6.0]
  def change
    change_column_default(:answers, :correct, from: false, to: true)
   @max-underthesun
max-underthesun on 7 Oct
если дефолты не были определены ранее, то "дефолт по дефолту" для любой колонки - nil
почему у тебя from: false ?
такой дефолты нигде ранее в твоих миграциях не установлен, значит правильно будет from: nil
   @max-underthesun
max-underthesun on 7 Oct
второй момент - лучше обозначить дефолт to: false - большинство ответов будут неверными (например 4 ответа на вопрос, один верный и 3 неверных - нужно выбрать)




 movies = Movie.create([{ name: 'Star Wars' }, { name: 'Lord of the Rings' }])
#   Character.create(name: 'Luke', movie: movies.first)
Question.create([{ title: 'How do I do?' }, \
   @max-underthesun
max-underthesun on 7 Oct
лучше использовать create! - метод бросит исключение, если запись не создастся
сразу будет видно, если что-то пошло не так
   @max-underthesun
max-underthesun on 7 Oct
слеши не нужны при написании коллекций строку можно заканчивать просто запятой

 { title: 'Do I like rain?' }, { title: '^ is ?' }])

 Category.create([{title: 'About me', question_id: 1 }, \
  { title: 'About me', question_id: 2 }, { title: 'About weather', question_id: 3 }, \
   @max-underthesun
max-underthesun on 7 Oct
"хардкодить" id - не очень хорошая затея
такой "сид" невозможно накатить на существующую базу, ведь там id могут быть заняты другими записями или вовсе отсутствовать
   @max-underthesun
max-underthesun on 7 Oct
правильней воспользоваться тем, что метод create возвращает созданные записи
если их присвоить в переменные, то у тебя будут массивы объектов доступны для дальнейшего использования этих объектов в последующих криэйтах

categories = Category.create!([
  { title: ... },
  ...
  { ... }
])
далее можно в создании тестов не "хардкодить" ай-дишники, а вытаскивать их из объектов класса Category, хранящихся в переменной categories

tests = Test.all.order(title: :desc)
    tests.inject([]) do |acc, elem|
      current_category = Category.find(elem.category_id)
      current_category.title == category ? [*acc, elem.title] : acc
Comment on lines 3 to 6
Beta Send feedback
   @max-underthesun
max-underthesun on 7 Oct
запрос будет правильно решить через джойн таблиц (ты знаком с SQL ?)
то как ты делаешь - это "решение в лоб"
оно работает, но оно скажем мягко "не оптимальное" (количество запросов к базе будет по количеству тестов в базе - это очень громоздко)
в реальной жизни такие запросы писать не нужно
плюс мы сейчас пытаемся разобраться с тем, как работают ассоциации в рельсах, чтобы в дальнейшем было понимание того "что же они делают" и "как это работает", так вот рельсы точно не пишут такие запросы, конечно же все оптимизировано
здесь нужно в обоих методах (тут и в классе Юзер) решить все с помощью joins и where (в одно обращение к базе, один запрос)
пострайся разобраться - это важно и полезно
если будут вопросы - пиши в слак

users = User.where('name == ?', name)
    users.inject([]) do |acc, elem|
      test = Test.find(elem.test_id)
      test.level == level ? [*acc, test] : acc
Comment on lines 3 to 6
Beta Send feedback
   @max-underthesun
max-underthesun on 7 Oct
посмотри комментарий в классе Тест
плюс у тебя тут пользователь ищется и этот момент загадочен
во-первых он ищется по имени, но имя никак не приходит в метод
если это имя текущего пользователя, т.е. self, то зачем этого пользователя искать - он доступен через self
   @max-underthesun
max-underthesun on 7 Oct
что за связь между пользователем и тестом через ключ test_id в таблице users тоже не очень ясно
а если пользователь прошел несколько тестов, то какое значение будет записано в поле test_id ?

задачку про "пройденные тесты" правильно решать через соединительную таблицу
нужно добавить модель, к примеру Result или UsersTest и соответсвенную таблицу (users_tests или results)
другими словами нужны "промежуточная модель" и "соединительная таблица"
такая таблица ("соединительная") обычно в минимальном виде хранит два внешних ключа на таблицы, которые соединяет
когда пользователь проходит тест в этой таблице должна появляться запись содержащая соответсвенно ай-ди этого пользователя и ай-ди пройденного теста
(подробней можешь посмотреть в документации к рельсам про соединительные модели, таблицы)

class Test < ApplicationRecord
  def self.sort_by_category(category)
    Test.select(:title).joins('JOIN categories ON tests.id = categories.test_id')\
   @max-underthesun
max-underthesun on 8 Oct
слеш не нужен - в руби можно переносить "по точке" без слеша
   @max-underthesun
max-underthesun on 8 Oct
можно начинать сразу с select без явного обозначения класса, т.к. в класс-методе "селф" и будет этим классом
   @max-underthesun
max-underthesun on 8 Oct
эта запись 'JOIN categories ON tests.id = categories.test_id'предполагает, что таблица категорий хранит ссылку на тест, т.е. связь получается "у категории ноль или один и только один тест" со стороны категорий и видимо "у теста ноль или много категорий" со стороны теста - каое-то здесь противоречие
по идее должно быть наоборот:

тест может быть только одной категории
несколько разных тестов могут быть одной категории

class Test < ApplicationRecord
  def self.sort_by_category(category)
    Test.select(:title).joins('JOIN categories ON tests.id = categories.test_id')\
      .where("categories.title == ?", category)\
   @max-underthesun
max-underthesun on 8 Oct
условия на таблицы можно накладывать через хэши

.where(categories: { title: ... })
их проще изменять и легче читат

class Test < ApplicationRecord
  def self.sort_by_category(category)
    Test.select(:title).joins('JOIN categories ON tests.id = categories.test_id')\
   @max-underthesun
max-underthesun on 8 Oct
как я понимаю не совсем точно выполнено ТЗ

который возвращает отсортированный по убыванию массив названий
метод select вернет relation object (вот посмотри документацию: https://apidock.com/rails/v4.0.2/ActiveRecord/QueryMethods/select - 2-ой пример)

для возврата массива можно воспользоваться методом pluck (https://guides.rubyonrails.org/active_record_querying.html#pluck)

class User < ApplicationRecord
  def test_list_on_level(level)
    Test.joins('JOIN users_tests ON tests.id = users_tests.test_id').where("level == ? AND user_id == ?", level, id)
   @max-underthesun
max-underthesun on 8 Oct
тоже можно where преписать в хеш-нотации

class AddDetailsToCategories < ActiveRecord::Migration[6.0]
  def change
    change_column_null(:categories, :title, false)
    add_reference :categories, :question, foreign_key: true
    add_reference :categories, :test, foreign_key: true
   @max-underthesun
max-underthesun on 8 Oct
вот это похоже лишнее -  см. комментарии в начале

 def change
    change_column_default(:users_tests, :result, from: nil, to: false)
    add_reference :users_tests, :test, foreign_key: true
    add_reference :users_tests, :user, foreign_key: true
  end
Comment on lines 2 to 6
Beta Send feedback
   @max-underthesun
max-underthesun on 8 Oct
можно было это все при создании таблицы прописать, зачем лишняя миграция?

add_reference :users_tests, :test, foreign_key: true
    add_reference :users_tests, :user, foreign_key: true
Comment on lines 8 to 9
Beta Send feedback
   @max-underthesun
max-underthesun on 8 Oct
можно было внутри блока create_table эти ключи создать
только метод t.references вместо add_reference использовать





class Category < ApplicationRecord
  has_many :tests
   @max-underthesun
max-underthesun on 9 Oct
что произойдет с тестами, если категорию удалили?
сейчас будет ошибка: рельсы по умолчанию проверяют наличие ассоциированного объекта для всех belongs_to ассоциаций и выбрасывают ошибку валидации, если объекта не существует
(в таблице tests останется в поле category_id ссылка на несуществующий объект)

для всех has_* ассоциаций следует указывать поведение при удалении
посмотри в документации - опция dependent: ...

class Question < ApplicationRecord
  has_many :answers
  belongs_to :test
   @max-underthesun
max-underthesun on 9 Oct
рекомендуется сначала писать все belongs_to, а уже после них все has_many ассоциации

 has_many :users_tests
  has_many :users, through: :users_tests
  belongs_to :user

   def self.sort_by_category(category)
    joins('JOIN categories ON tests.category_id = categories.id')
   @max-underthesun
max-underthesun on 9 Oct
теперь благодаря ассоциациям этот запрос можно сократить

class User < ApplicationRecord
  has_many :users_tests
  has_many :tests, through: :users_tests
  has_one :test
   @max-underthesun
max-underthesun on 9 Oct
а почему has_one ?
пользователь может создавать много тестов

 has_many :users_tests
  has_many :tests, through: :users_tests
  has_one :test

   def test_list_on_level(level)
   @max-underthesun
max-underthesun on 9 Oct
здесь в методе можно значительно упростить код
у тебя теперь есть ассоциация, которая вернет список всех тестов пользователя

belongs_to :category
  has_many :users_tests
  has_many :users, through: :users_tests
  belongs_to :user
   @max-underthesun
max-underthesun on 9 Oct
рекомендуется обычно, чтбы не путать ассоциации давать им имена более специфичные
у тебя уже есть users
ассоциацию для авторства можно назвать author (посмотри в документации как правильно реализовывать ассоциации не совпадающие по имени с именем таблицы)

tests = Test.create!([{ title: 'Vasiliy', category_id: categories[0].id },
  { title: 'Weather', category_id: categories[1].id },
  { title: 'JavaScript', category_id: categories[2].id }
tests = Test.create!([{ title: 'Vasiliy', category_id: categories[0].id, user_id: users[0].id },
   @max-underthesun
max-underthesun on 9 Oct
теперь благодаря ассоциациям можно передавать модели: category: categories[0], author: users[0] и т.п. (без _id , .id)

class Category < ApplicationRecord
  has_many :tests, dependent: :destroy
   @max-underthesun
max-underthesun on 9 Oct
возможно не стоит терять все тесты при удалении категории
лучше просто сбросить ("обнулифаить") категорию, а не удалять тесты

при использовании dependent: :nullify в ответной ассоциации нужно добавить опцию optional: true - посмотри документацию, чтобы разобраться зачем она нужна

has_many :users, through: :users_tests, dependent: :destroy

   def self.sort_by_category(name)
    Category.find_by(title: name).tests.order('title desc').pluck(:title)
   @max-underthesun
max-underthesun on 9 Oct
этот запрос "хуже" предыдущего (тут будет 2 запроса к базе)
нужно использовать "старый" запрос
просто его можно упростить за счет использования ассоциации
посмотри доки про AcitveRecords queries - там есть примеры джойнов и с использованием строки, как было раньше, и с использованием ассоциаций

class User < ApplicationRecord
  has_many :users_tests, dependent: :destroy
  has_many :tests, through: :users_tests, dependent: :destroy
  has_many :test, foreign_key: "author_id", dependent: :destroy
   @max-underthesun
max-underthesun on 9 Oct
has_many :test - это как?
"имеет много тест" ???
назови как-то более адекватно
например created_tests

has_many :users_tests, dependent: :destroy
  has_many :tests, through: :users_tests, dependent: :destroy
Comment on lines 2 to 3
Beta Send feedback
   @max-underthesun
max-underthesun on 9 Oct
в has_many through ассоциациях dependentдостаточно использовать для связующей таблицы
(в данном случае для строки has_many :users_tests, ...

.where(categories: { title: category })
      .order('categories.title desc')
      .pluck(:title)
  belongs_to :user, foreign_key: "author_id"
   @max-underthesun
max-underthesun on 9 Oct
а чего не назвал ассоциацию author ?
так было бы проще и удобней

 add_column :tests, :author, :integer
    add_foreign_key :tests, :users, column: :author
Comment on lines 6 to 7
Beta Send feedback
   @max-underthesun
max-underthesun on 10 Oct
лучше использовать вот такой вариант:

add_reference :tests, :author, foreign_key: { to_table: :users }
создастся ключ author_id, который будет ссылаться на таблицу users
ключи правильно называть с постфиксом _id
в рельсах много дефолтного поведения построено на подобных конвенциях
отклоняясь от конвенций усложняешь жизнь себе и тем, кто будет твой код потом читать, поддерживать

belongs_to :user, foreign_key: "author", optional: true
  belongs_to :`author`, class_name: "User", foreign_key: "`author_id`", optional: true
Commit suggestion 
лучше ассоциацию и внешний ключ называть одинаково (author и author_id)
это удобней в использовании и это соответсвует дефолтному поведению рельс






class Answer < ApplicationRecord
  belongs_to :question
  validates :title, presence: true

   scope :correct_anwer, ->(id) { where(question_id: id, correct: "t") }
   @max-underthesun
max-underthesun on 10 Oct
Suggested change 
  scope :correct_anwer, ->(id) { where(question_id: id, correct: "t") }
  scope :correct, -> { where( correct: true) }
Commit suggestion 
не стоит дублировать имя класс в скоупе
по ТЗ нужен скоуп для выбора корректных ответов, про привязку к вопросу ничего не говорится и собственно это просто решается с помощью ассоциации
видимо я пропустил это - у тебя поле correct почему-то задано как string, хотя должно быть по заданию boolean - нужно исправить (либо откатить миграции, либо добавить миграцию и поменять тип поля), правильный синтаксис для булева поля я указал, соответсвенно дефолт нужно тоже ставить не строку, а булево (false)

class Category < ApplicationRecord
  has_many :tests, dependent: :nullify
  validates :title, presence: true

   default_scope { order(title: :asc) }
   @max-underthesun
max-underthesun on 10 Oct
default_scope глобально меняет поведение всех запросов к модели
поэтому его рекомендуют записывать в самом верху класса

 validates :title, presence: true
  validate :question_answers

   scope :correct_answer, ->(id) { Answer.joins(:question).where(answers: { correct: "t", question_id: id })  }
   @max-underthesun
max-underthesun on 10 Oct
этого скоупа нет в ТЗ
суть скоупа - накладывать некие условия на выборку объектов класса, для которого определен скоуп
благодаря этому скоупы обычно используют как-то так:
Answer.currect
...

question.aswers.correct
нет смысла писать скоуп возвращающий ответы в классе Вопрос - это противоречит самому определению скоупа и его ожидаемой функциональности

def question_answers
    answers_count = Answer.joins(:question).where(answers: { question_id: id }).count
    errors.add(:answers) if answers_count < 1 || answers_count > 4
  end
Comment on lines 9 to 12
Beta Send feedback
   @max-underthesun
max-underthesun on 10 Oct
ТЗ: "У одного Вопроса может быть от 1-го до 4-х ответов."
не очень понятно как валидация в модели Вопрос будет препятствовать созданию новых ответов в количестве больше 4... она же не будет вызываться, когда ты будешь добавлять новые ответы к вопросу
вызываются валидации того класса, объекты которого создаются
при создании нового объекта класса Ответ вызываются валидации класса Ответ, а не класса Вопрос

видимо ты не проверяла работу этой валидации

.order('categories.title desc')
      .pluck(:title)
  validates :level, numericality: { only_integer: true, greater_than_or_equal_to: 0 }
  validate :uniq_title_level, on: :create
   @max-underthesun
max-underthesun on 10 Oct
посмотри в документации есть "встроенный" метод валидации уникальности, воспользуйся им
   @max-underthesun
max-underthesun on 10 Oct
сначала рекомендуют писать все validates, потом все validate

scope :easy, -> { where(level: 0..1) }
  scope :medium, -> { where(level: 2..4) }
  scope :hard, -> { where(level: 1..Float::INFINITY) }
  scope :sort_by_category, ->(name) { joins(:category).where(categories: { title: name }).order('categories.title desc').pluck(:title) }
   @max-underthesun
max-underthesun on 10 Oct
у скоупов есть важная особенность - они должны возвращать chainable объекты (объекты ActiveRecord::Relation)
благодаря этому с их использованием можно строить цепочки вызовов
скоупы можно чейнить с квери-методами ActiveRecord, к примеру where(level: ...).order(id: :desc).created_last_week ..., с методами ассоциаций
квери-методы также возвращают объекты ActiveRecord::Relation
НО!
pluck вернет обычный массив, что нарушит эту конвенцию
поэтому, если скоуп должен вернуть объект или массив, но не ActiveRecord::Relation, то его лучше реализовывать обычными методами класса

здесь можно создать скоуп, который будет делать, к примеру, все кроме pluck
а при желании сохранить прежнюю функциональность можно оставить плюс к скоупу метод класса и уже в методе класса (из прошлого задания) убрать все запросы, вызвать этот скоуп и зачейнить его "плаком"

ANSWER_LIMIT = 4
  belongs_to :question
  validates :title, presence: true
  validate :question_answers
Comment on lines 2 to 5
Beta Send feedback
   @max-underthesun
max-underthesun on 11 Oct
обычно рекомендуется отделять константы пустой строкой и ассоциации с валидациями тоже лучше разделить пустой строкой

 def question_answers
    answers_count = Answer.where(question_id: question_id).count
    if answers_count == ANSWER_LIMIT
   @max-underthesun
max-underthesun on 11 Oct
Suggested change 
    if answers_count == ANSWER_LIMIT
    if answers_count >= ANSWER_LIMIT
Commit suggestion 
я бы из паранойи использовал >=
например такой сценарий:

в базе 3 записи и два пользователя одновременно создают новый ответ с разных компов
на момент создания - это валидная операция для каждого из них
в базе в итоге 5 ответов и это не очень хорошо
что еще хуже, это то, что можно продолжить создавать ответы, потому что ответов не 4, а в проверке строгое равенство






question_id = params['id']
    Question.find_by_id(question_id).destroy
Comment on lines 27 to 28
Beta Send feedback
   @max-underthesun
max-underthesun 29 days ago
у тебя поиск вопроса в "шоу" и в "дестрой"
правильно будет его реализовать так же как поиск теста (Question.find(params[:id])) для обоих экшенов и , т.к. он повторяется - вынести в коллбек, также, как для теста


Rails.application.routes.draw do
  # For details on the DSL available within this file, see https://guides.rubyonrails.org/routing.html
  resources :tests do
    resources :questions
   @max-underthesun
max-underthesun 29 days ago
для "облегчения" роутинга рекомендуется использовать (где это возможно и приемлимо) опцию shallow: true
вот документация на русском
вот вот на английском
   @max-underthesun
max-underthesun 29 days ago
и надо будет поправить контроллер (тест нужен и доступен будет уже не для всех экшенов)





before_action :find_question
  before_action :find_test
Comment on lines 2 to 3
Beta Send feedback
   @max-underthesun
max-underthesun 28 days ago
используй опции only, except (обычно рекомендован первый вариант)
тебе не для всех экшенов нужны объекты теста и вопроса, обозначь это здесь


   def find_question
    @question = Question.find(params[:id]) if params[:id]
   @max-underthesun
max-underthesun 28 days ago
отредактируй before_action и убери здесь if

 if params[:test_id]
      @test = Test.find(params[:test_id])
    else
      @test = Test.find(@question.test_id)
    end
Comment on lines 50 to 54
Beta Send feedback
   @max-underthesun
max-underthesun 28 days ago
оставь только 51 строку, поправь before_action
53 строка реализуется через ассоциацию: @test = @question.test
лучше ее использовать не в коллбеке с условием, а в конкретном экшене или даже во вьюхе непосредственно

 def edit
  end
Comment on lines 24 to 25
Beta Send feedback
   @max-underthesun
max-underthesun 28 days ago
пустые экшены рекомендуется записывать в виде

def show; end

def index
    questions = @test.questions.pluck(:title)
    render html: "<p>#{questions.join("<br>")}</p>".html_safe
  end
Comment on lines 8 to 9
Beta Send feedback
   @max-underthesun
max-underthesun 28 days ago
ТЗ: "Список вопросов теста должен выводиться на той же странице, что и сам тест"

другими словами - в этом контроллере этот экшен не нужен, индекс вопросов конкретного теста должен выводиться на странице этого теста (TestsController #show и соответствующая вьюха) , как у тебя и сделано
здесь экшен нужно убрать и вьюху тоже
(также не забудь убрать роут и поправить вызов коллбека)

def show
    render html: @question.title
    @question
  end

   def destroy
   @max-underthesun
max-underthesun 28 days ago
в экшене destroy редирект стоит сделать на страницу теста

class TestsController < ApplicationController
   @max-underthesun
max-underthesun 28 days ago
скромный получился контроллер )
а где же остальные экшены?
повтори все что было в скринкасте
здесь нужен весь набор экшенов

private

   def find_test
    @test = Test.find(params[:id]) if params[:id]
   @max-underthesun
max-underthesun 28 days ago
"иф" не нужен, используй опции before_action

METHODS = { create: 'Create', edit: 'Edit' }.freeze

   def question_header(method, test)
    "#{METHODS[method]} #{test.title} Question"
  end
Comment on lines 2 to 6
Beta Send feedback
   @max-underthesun
max-underthesun 28 days ago
в хелпер достаточно передавать question
он доступен в обеих вьюхах

тест можно найти через ассоциацию

для определения создается ресурс или редактируется лучше использовать хелперы .persisted? или .new_record?, а не передавть из вьюхи имя метода

module ApplicationHelper
  def year
    Time.new.year
   @max-underthesun
max-underthesun 28 days ago
в рельсах рекомендуется использовать Time.current вместо Time.now (Time.new) и Date.current вместо Date.today
.current возвращает текущий момент времени с учетом настройки часового пояса в приложении

</div>

   <div class="card-body">
    <%= render 'form', parent: @tests, child: @question %>
   @max-underthesun
max-underthesun 28 days ago
почему @tests ??? нужен конкретный тест а не коллекция
можно не передавать явно переменные - в паршеле доступны инстанс-переменные (@test, @question)

 <% @test.questions.each do |que| %>
      <th class="list-group-item"><%= que.title %></th>
      <% end %>
Comment on lines 9 to 11
Beta Send feedback
   @max-underthesun
max-underthesun 28 days ago
рендериг коллекции лучше реализовать как показано в скринкасте для @tests
через render @test.questions и соответсвующий паршел

<%= form_with model: [@test, @question], local: true do |form| %>
   @max-underthesun
max-underthesun 27 days ago
проверь
у тебя на редактировании не должна работать эта форма
из-за того что ты определил в контроллере @test в экшене "эдит"
при "шеллоу тру" и наличии объекта теста рельсы не смогут построить правлильный путь из вот этого: [@test, @question]
нужно чтобы @test был пустой
решение - определять тест не в контроллере, а там где это нужно, т.е. во вьюхе (@question.test)







before_validation :before_validation_set_first_question, on: :create
  after_save :next_question
Comment on lines 6 to 7
Beta Send feedback
   @max-underthesun
max-underthesun 26 days ago
эти два коллбека делают одно и то же по сути
оба устанавливают следующий вопрос
разница лишь в том, что считать следующим вопросом, т.е разница в поиске этого следующего вопроса
имеет смысл объединить их в один простой коллбек:

before_validation :set_current_question

...

def set_current_question
  self.current_question = next_question
end
а всю различающуюся логику поместить уже в метод next_question

(коллбеки усложняют код и его отладку, если есть возможность не плодить лишние, то ей надо воспользоваться)

 if correct_answer?(answer_ids)
      self.correct_questions += 1
    end
Comment on lines 14 to 16
Beta Send feedback
   @max-underthesun
max-underthesun 26 days ago
однострочник с постфиксным if будет проще читаться

<div>
  <p> Correct questions: 
  <% if pass_test?(@test_passage) %>
   @max-underthesun
max-underthesun 26 days ago
в хелперах не должны быть бизнес-логики - ее место в модели (хелперы нужны для выделения логики рендеринга из вьюх)
расчет %, определение успешности прохождения теста - все это является бизнес-логикой

здесь правльней будет такой вариант:

<% if @tets_passage.passed? %>
т.е. все рассчеты и проверки верно будет реализовать в модели

<div>
  <p> Correct questions: 
  <% if pass_test?(@test_passage) %>
    <span style="color:green"><%= @test_passage.correct_questions  %></span> Successful
   @max-underthesun
max-underthesun 26 days ago
стилизацию лучше делать через css классы:
создать классы, к примеру .test_passage.succes, .test_passage.fail и в файлах css описать стили
соответственно в шаблоне нужно просто использовать "правильные" css классы в зависимости от успешности / неуспешности @test_passage

 <%= @test_passage.current_question.title %>
</div>
<div>
  Current question - <%= current_question @test_passage %>; 
   @max-underthesun
max-underthesun 26 days ago
Suggested change 
  Current question - <%= current_question @test_passage %>; 
  Current question - <%= @test_passage.current_question_number %>; 
Commit suggestion 
это тоже бизнес логика, нужно ее реализовывать в модели
название метода неудачное - он ведь возвращает не объект, номер, так и надо в названии отразить

member do
      post :start
    end
Comment on lines 8 to 10
Beta Send feedback
   @max-underthesun
max-underthesun 26 days ago
когда всего одна строчка, проще написать

post :start, on: :member

create_table :test_passages do |t|
      t.references :user, null: false, foreign_key: true
      t.references :test, null: false, foreign_key: true
      t.references :current_question, null: false, foreign_key: true
   @max-underthesun
max-underthesun 26 days ago
эта миграция вызовет проблемы при деплое, т.к. внешний ключ создается к несуществующей таблице (при деплое будет использована постгрес, она не пропустит такую миграцию)

когда создается внешний ключ, с помощью метода add_referenceимя таблицы вычисляется из имени второго аргумента
в этом случае второй аргумент :current_question
значит будет создано поле :current_question_id, которое (без дополнительных настроек) будет ссылаться на таблицу current_questions
такой таблицы не существует

похожая задача уже решалась, когда нужно было добавить вторую ассоциацию между тестами и пользователями, чтобы хранить связь с автором теста


   def next_question
    if current_question
   @max-underthesun
max-underthesun 25 days ago
лучше здесь вместо if current_question проверять new_record? - это более прямолинейно отражает логику: "если новое прохождение теста, то первый вопрос"

"<span class=\"success\">#{test_passage.correct_questions}</span><b> Successful</b>".html_safe
    else
      "<span class=\"fail\">#{test_passage.correct_questions}</span><b> not Successful</b>".html_safe
Comment on lines 4 to 6
Beta Send feedback
   @max-underthesun
max-underthesun 25 days ago
htmlконечно правильней реализовывать во вьюхе
хелпер в первую очередь предназначен для изоляции логики
конечно можно в хелперах писать html, но когда можно этого избежать без потери качества кода, стоит это делать
в данном случае, мне кажется, лучше уж логику перенести во вьюху (ее немного и она простая), чем html в хелпер
ТЗ: "Выводите сообщение и процент успеха в зависимости от количества правильных ответов"
обрати внимание на "и процент успеха" - эта часть не реализована

def current_question_number
    current_id = current_question.id
    test.questions.where('id < ?', current_id).count + 1
   @max-underthesun
max-underthesun 25 days ago
не настаиваю
но еще можно так:

Suggested change 
    test.questions.where('id < ?', current_id).count + 1
    test.questions.where('id <= ?', current_question.id).count
Commit suggestion 
и 24 строку убрать







def authenticate_user!
    redirect_to login_path unless current_user
    session[:referer] = request.url
   @max-underthesun
max-underthesun 25 days ago  • 
edited 
урл для редиректа нужен на тот случай, если юзер не авторизован и пытается куда-то зайти, куда без авторизации нельзя
урл сохраняется, юзер отправляется на страницу логина и после авторизации юзера редиректит куда он хотел изначально
в текущем варианте урл сохраняется для уже авторизованного пользователя, смысла в этом нет

user = User.find_by(email: params[:email])
    if user&.authenticate(params[:email])
      session[:user_id] = user.id
      redirect_to session[:referer]
   @max-underthesun
max-underthesun 25 days ago
в куках может быть пусто, в этом случае надо редиректить на какую-то дефолтную страницу
   @max-underthesun
max-underthesun 25 days ago
также лучше сразу удалить из кук сохраненный путь - он больше не понадобится

def set_user
    @user = User.first
    @user = User.find_by(id: session[:user_id])
   @max-underthesun
max-underthesun 25 days ago
в ApplicationController определен метод current_user (12-14 строки)
зачем здесь дублировать его функциональность, если можно им воспользоваться?
и правильней им воспользоваться прямо в том экшене, где он нужен, без "сет юзер"

def flash_alert(alert)
    if alert
      content_tag :p, alert, class: 'flash alert'
    end
  end
Comment on lines 2 to 6
Beta Send feedback
   @max-underthesun
max-underthesun 25 days ago
здесь более правильно было бы принимать в аргументах type
потому что флеш-сообщения могут быть разных типов, а этот хелпер вернет сообщение, только если это :alert
получить сообщение для любого типа можно так: flash[type]

get :login, to: 'sessions#new'
  get :signup, to: 'users#new'
  put :signout, to: 'sessions#sign_out'
   @max-underthesun
max-underthesun 25 days ago
соблюдай конвенции REST: удаление ресурса (сессии) логично делать через DELETE, а не через PUT
   @max-underthesun
max-underthesun 25 days ago
а в контроллере правильно использовать экшен #destroy для удаления объекта (сессии)

if session[:referer]
        redirect_to session[:referer]
        session.delete(:referer)
      else
        redirect_to tests_path
      end
Comment on lines 9 to 14
Beta Send feedback
   @max-underthesun
max-underthesun 24 days ago
в руби (и рельсах) для установки дефолта обычно используют такую конструкцию:

value = calculate_value || default_value
точно так же можно и здесь вместо "иф-элс" блока решить через ||

redirect_to path || defalt_path
такой вариант будет более каноничный и привычный для рубиста
   @max-underthesun
max-underthesun 24 days ago
также лучше сразу удалить из кук :referer (на редиректе)
к примеру, метод delete возвращает удаленное из коллекции значение и с его помощью можно реализовать этот код вот так:

redirect_to cookies.delete(:referer) || tests_path

def flash_alert(type)
    if alert
      content_tag :p, type, class: 'flash alert'
    end
  end
Comment on lines 2 to 6
Beta Send feedback
   @max-underthesun
max-underthesun 24 days ago
type может придти разный в хелпер
:alert, :notice и т.д.
поэтому сообщение нужно получать из объекта flash обращаясь по этому ключу (в прошлый раз уже писал, посмотри предыдущий комментарий)
к примеру flash[:alert] вернет сообщение, если оно есть, по ключу :alert
при этом проверка тоже должна быть на существование сообщения по этому ключу, т.е. по type
и css класс конечно же тоже надо строить в зависимости от ключа, чтобы для разных ключей был соответсвующий класс







class Users::SessionsController < Devise::SessionsController
  # before_action :configure_sign_in_params, only: [:create]

   def after_sign_in_path_for(resource)
   @max-underthesun
max-underthesun 22 days ago
у нас ресурсом может быть только пользователь
там, где есть возможность с помощью удачного названия переменной или метода облегчить чтение кода, не нужно использовать абстрактный "нейминг" - он чтение усложняет

def after_sign_in_path_for(resource)
    if resource.is_a?(Admin)
   @max-underthesun
max-underthesun 22 days ago
механизм проверки на админа стоит вынести в модель
здесь более правильно будет использовать что-то типа

if user.admin?

@test = Test.new(test_params)
    @test.update(author_id: current_user)
Comment on lines 26 to 27
Beta Send feedback
   @max-underthesun
max-underthesun 22 days ago
авторство правильней задавать через ассоциации
автор - текущий пользователь, у модели User есть ассоциация с Test, как раз для обозначения авторства
в контроллере вопросов через ассоциации создается новый вопрос с установленным внешним ключом для таблицы tests - здесь возможно аналогичное решение для авторства








question = @test_passage.current_question
    result = GistQuestionService.new(question).call
    flash_options =
      if result
@max-underthesun
max-underthesun 21 days ago

наличие проверки на пустой ответ - хорошо, но еще важно убедиться, что пришел не пустой html_url - это и есть критерий успешного создания гиста
ответ может быть не nil, но гист при этом может быть не создан
по сути nil будет только если "все совсем пошло не так"... но возможно, что ГитХаб ответил (ответ будет не nil), но гист не создался при этом и соответственно hmtl_url будет пустой
это рассуждение и нужно взять за основу создания "правильной проверки" успешности создания гиста
@max-underthesun
max-underthesun 21 days ago

здесь можно пойти 2-мя путями
первый - добавить метод success? в сервис и здесь решать как-то так:

def gist
  service = GistQuestionService.new(@test_passage.current_question)
  service.call
  if service.success?
    ...

в этом варианте нужно будет в сервисе сохранить в переменную результат, который вернется с гитхаба и далее этим результатом пользоваться обращаясь к сервису

другой путь (даже более "правильный" наверное), но немного более сложный - написать сервис так, чтобы он возвращал не непосредственно тот объект, который вернулся с гитхаба, а некий специальный объект, построенный на основании ответа с гитхаба, некий объект класса Резалт (его можно определить прямо внутри сервиса, как полноценный класс или воспользоваться Struct)
такой объект result должен нести всю нужную информацию и отзываться на метод success?

в этом варианте, здесь код будет выглядеть примерно так:

def gist
  result = GistQuestionService.new(@test_passage.current_question).call
  if result.success?
    ...

def gist
    question = @test_passage.current_question
    result = GistQuestionService.new(question).call
    flash_options =
@max-underthesun
max-underthesun 21 days ago

мне кажется не очень удачным вариант создания объекта внутри операции присвоения:

flash_option = if ...
  Gist.create(...

особенно с учетом, что гист в данном контексте "объект первого класса" - нас интересует в первую очередь он, а присвоение флеша - функция второстепенная
я бы порекомендовал здесь решать через обычный if...else блок и лучше сразу писать полноценные флеши, а не flash_option
в таком стиле:

if result.success?
  Gist.create(...)
  flash[:notice] = ...

 html_url = result['html_url']
        Gist.create!(question: question, user: current_user, url: html_url)

        { notice: t('.success', url: html_url) }
@max-underthesun
max-underthesun 21 days ago

    ТЗ: "Выводите ссылку на созданный gist во flash сообщении"

как я понимаю в текущем варианте во флеше выводится не ссылка ("кликабельная") а просто урл (строка)
по заданию нужна "кликабельная" ссылка, т.е должно работать так:

    после создания гиста выводится флеш со ссылкой
    делаем клик по ссылке из флеша и переходим на страницу гиста

class Gist < ApplicationRecord
@max-underthesun
max-underthesun 21 days ago

думаю объект класса Гист без ссылки на гист смысла не имеет
правильный подход - валидировать наличие обязательных аттрибутов


 belongs_to :test
  has_many :answers, dependent: :destroy
  has_many :test_passages
  has_many :gists
@max-underthesun
max-underthesun 21 days ago

опцию dependent нужно указывать для всех has_ ассоциаций

class GistQuestionService
  def initialize(question, client: nil)
@max-underthesun
max-underthesun 21 days ago

установка "нил" в аргументах - не лучшее решение
более правильный вариант установки дефолта будет выглядеть, к примеру, так:

def initialize(question, client = default_client)
  ...
  @client = client
end

далее можно определить в методе default_client "дефолтного клиента"

private

def default_client
  ...
end

<tr>
  <td><%= link_to "#{gist.question.title}"[0...25], admin_question_path(gist.question) %></td>
@max-underthesun
max-underthesun 21 days ago

здесь лучше использовать хелпер truncate - вот небольшой пост про него

<tr>
  <td><%= link_to "#{gist.question.title}"[0...25], admin_question_path(gist.question) %></td>
  <td><%=  link_to 'Gist', gist.url, target: "_blank" %></td>
@max-underthesun
max-underthesun 21 days ago

ТЗ: "Отображается хэш созданного gist в виде ссылки"
у тебя здесь отображается строка 'Gist'
именем нужно назначить "хеш" из "урла" (гитхабовский текстовый идентификатор в конце url-а)

<tr>
  <td><%= link_to truncate("gist.question.title", length: 25), admin_question_path(gist.question) %></td>
  <td><%=  link_to gist.url, gist.url, target: "_blank" %></td>
@max-underthesun
max-underthesun 20 days ago

здесь отображается полностью тот же "урл" на который идет редирект, а нужно отображать "хеш" из этого "урла"
последняя часть урла, набор букв и цифр

f result.success?
      html_url = result['html_url']
      Gist.create(question: question, user: current_user, url: html_url)
      flash[:notice] = t('.success_html', url: html_url)
@max-underthesun
max-underthesun 20 days ago

не вижу доработок по этому комментарию: #1 (comment)

<% flash.each do |key, message| %>
  <%= content_tag :p, message, class: "flash #{key}" %>
  <% if message.is_a?(Array) %>
@max-underthesun
max-underthesun 20 days ago

передачу ссылки не так надо было реализовывать, слишком сложно получилось и слишком специфично
можно проще
первый вариант:

    метод t принимает аргументы, можно в контроллере вызвать его вот так: t('.success', url: gist.url)
    далее можно в фале локали под ключом sucsess сформировать строку вида "<a href=...>" куда с помощью экстраполяции вписать урл

второй вариант, возможно более правильный:

    из контроллера передавать во флеш уже сформированную ссылку, примерно так: flash[:notice] = view_context.link_to(t('.success'), gist.url, target: "_blank")

в обоих случаях нужно вот здесь оставить старый простой паршел обработки флешей, только к message добавить message.html_safe








если я ничего не упустил, то главный недостаток решения следующий:

в текущем варианте проверка таймера происходит только на клиенте и прекращается тест только со стороны клиента
НО! выполнение жи-эс можно "хакнуть" или просто отключить
важно продублировать проверку таймера со стороны сервера и прекращать прохождение теста средствами рельс, если время истекло
app/controllers/test_passages_controller.rb Outdated
@@ -3,6 +3,7 @@ class TestPassagesController < ApplicationController
  before_action :set_test_passage, only: %i[show update result gist]

   def update
    timer_date_to_js
   @max-underthesun
max-underthesun 17 days ago
не стоит грузить контроллер лишними функциями
логику лучше реализовывать в модели или в сервисах
к примеру на каждом апдейте вызывается метод accept!
почему бы не привязать запуск логики таймера к нему

def set_test_passage
    @test_passage = TestPassage.find(params[:id])
  end

   def timer_date_to_js
   @max-underthesun
max-underthesun 17 days ago
в модель

timerId = setInterval(() => {
      time -= 1;
      if (!window.location.href.match(match)) {
   @max-underthesun
max-underthesun 16 days ago
проще такие проверки реализовывать по наличию какого-то элемента на странице

def update
    @test_passage.accept!(params[:answer_ids])
    if @test_passage.completed?
    if @test_passage.completed? || @test_passage.spent_time?
   @max-underthesun
max-underthesun 16 days ago
уже писал в прошлый раз
лучше логику реализовать в модели
не грузи контроллеры кодом
у тебя уже есть проверка if @test_passage.completed?
просто в accept! заверши тест, если таймер вышел - это ведь логично
и здесь тоже все отработает логично: тест завершен - переходим на страницу результата
по сути таймер - это еще одно условие завершения теста
раньше он завершался по окончанию вопросов только, а теперь еще по таймеру может завершиться







scope :user_tests, ->(test, user) { where(test: test, user: user) }

   def self.pass_test?(test, user)
    tests = TestPassage.user_tests(test, user)
   @max-underthesun
max-underthesun 17 days ago
путающие названия переменных
выбираешь из таблицы test_passages, при этом переменная называется test
   @max-underthesun
max-underthesun 17 days ago
вообще метод довольно сложно написан (по крайней мере с точки зрения "руби стайла" точно)
как я понимаю он должен проверить существуют ли успешные прохождения данного теста для данного пользователя
если так, то лушче ввести аттрибут, к примеру successful для таблицы test_passages и во время прохождения теста его обновлять (можно в accept!), тогда по завершению теста у нас уже будет флаг успешности теста
выбрать все успешные прохождения можно будет по этому флагу простым запросом
соотетветсвенно определить были ли успешные прохождения тоже становится очень просто


t.references :test, foreign_key: true
      t.references :category, foreign_key: true
      t.integer :attempts, default: 0
      t.integer :under_level, default: 10
      t.integer :above_level, default: 0
Comment on lines 6 to 10
Beta Send feedback
   @max-underthesun
max-underthesun 17 days ago
сложная структура, много полей, по сути для каждого правила создан отдельный набор полей
это означает, что ситуация скорее всего будет ухудшаться при добавлении новых правил выдачи бейджей, таблица и модель будут распухать, код придется дописывать в нескольких точках

здесь было бы более оптимально реализовать все через 2 поля: "имя правила" + "параметр правила"
пример:

имя_павила: "за все тесты категории"
параметр_правила: "бэкэнд"
при добавлении новых правил новые поля в таблицу добавлять не нужно


if @test_passage.passed?
      Badge.all.each do |badge|
        if badge.give?(@test_passage.test, current_user)
          UsersBadge.create!(user: current_user, badge: badge)
        end
      end
Comment on lines 18 to 23
Beta Send feedback
   @max-underthesun
max-underthesun 17 days ago
не стоит перегружать контроллер бизнес-логикой
контроллер должен быть минималистичен и по возможности заниматься только самыми простыми задачами типа "создал или нашел объект, проверил валидность объекта, сохранил объект, принял решение о рендеринге или редиректе"

всю логику связанную с выдачей бейдже стоит спрятать в специальный сервис (к примеру BadgeService)

в контроллере нужно оставить только что-то такое:

current_user.badges << BadgeService.new(@test_passage).badges
   @max-underthesun
max-underthesun 17 days ago
и возможно выдачу бейджей лучше прописать в экшене update в ветке if @test_passage.completed?


 private

   def check_attempts
   @max-underthesun
max-underthesun 17 days ago
методы проверки выполнения правил лучше унести из модели в сервис (уже написал про это выше)
в моделях желательно концентрировать логику связанную с самыми базисными функциями и информацией, относящимися к объекту (валидации, скоупы, коллбеки, ассоциации и т.п.)
(если пойти еще дальше, то возможно даже более верно вынести правила в отдельные классы, к примеру подклассы суперкласса Rule, хотя на уровне этого проекта такая реализация скорее всего ненужное усложнение)

validates :name, presence: true
  validates :picture_file, presence: true
  validates :rule_parameter, presence: true
  validates :rule_name, presence: true
   @max-underthesun
max-underthesun 17 days ago
было бы правильно хранить список правил в модели и проверять, что значение аттрибута rule_name входит в этот список
   @max-underthesun
max-underthesun 17 days ago
в текущем варианте можно создавать бейджи с одинаковым правилом (совпадающие по паре атрибутов rule_type и rule_parameter)
можно создать 2 разных бейджа за одно и то же достижение
наверное это не совсем правильно

if badge.rule_name == 'All test from category'
        UsersBadge.create!(user: @user, badge: badge) if all_test_from_category(badge) 
      elsif badge.rule_name == 'Test with 1 attempt'
        UsersBadge.create!(user: @user, badge: badge) if test_with_one_attempt(badge)
      elsif badge.rule_name == 'All test with level'
        UsersBadge.create!(user: @user, badge: badge) if all_test_with_level(badge.rule_parameter)
      end
Comment on lines 9 to 15
Beta Send feedback
   @max-underthesun
max-underthesun 17 days ago
сложная реализация
лучше чтобы имена правил, храняшиеся в таблице, совпадали с именами методов, проверяющих выполнение этих правил, тогда можно все реализовать в одну строчку, через send (вспомни модуль валидаций в курсе по руби)
   @max-underthesun
max-underthesun 17 days ago
будет правильней, если сервис просто вернет список доступных пользователю бейджей (не выдавая их пользователю)

во-первых это более правильно с точки зрения разделения ответственности - сервис будет только выбирать нужные бейджи и возвращать их список вызывающему коду - одна отвественность (в текущей ситуации он еще и "выдает бейджи", т.е. две функции, что не так хорошо)

во-вторых (хотя это скорее следствие предыдущего пункта) сервис таким образом станет более универсальным и независимым

любой вызывающий код может им воспользоваться и уже самостоятельно решить, что делать с бейджами: присвоить их пользователю, вывести на экран или послать письмом

также такой код будет проще тестировать

присвоить бейджи в контроллере можно так, как я уже предлагал в прошлый раз:

current_user.badges << BadgeService.new(@test_passage).badges


   def badges
    Badge.all.each do |badge|
   @max-underthesun
max-underthesun 17 days ago
для выбора коллекции из другой коллекции удобно использовать https://ruby-doc.org/core-2.6.1/Enumerable.html#method-i-select

 private

   def all_test_from_category(badge)
   @max-underthesun
max-underthesun 17 days ago
стоит убедиться, что категория текущего теста совпадает с категорией, для которой установлено правило, а если нет - то нет смысла обращаться к базе

def all_test_from_category(badge)
    check = true
    badge.category.tests.each do |item|
   @max-underthesun
max-underthesun 17 days ago
здесь ты test назвал item, в модели trial
приходится мотаться по разным файлам, чтобы отследить что это на самом деле
очень неудобно
называй вещи своими именами
   @max-underthesun
max-underthesun 17 days ago
вообще вся проверка сложно написана
и у меня впечатление, что она не проверяет то что нужно
проверка должна по сути убедиться, что пользователь "прошел все тесты определенной категории успешно"
как я понимаю твою проверку она проверяет, что пользователь "прошел хотя бы один раз этот тест"
значение категории нигде даже не используется в твоей проверке
решать нужно через запросы к базе и сравнение их результатов
убери эти громоздкие циклы и временные флаги
читать сложно, работает неверно, выглядит, как костыли
   @max-underthesun
max-underthesun 17 days ago
аналогичные замечания по остальным методам
   @max-underthesun
max-underthesun 17 days ago
кстати успешность не вижу, чтобы проверял текущего прохождения

private

   def all_test_from_category(badge)
    if badge.category == @test.category
   @max-underthesun
max-underthesun 16 days ago
вместо вкладывания всего метода в if...end рекомендуется писать guard clause
вот к примеру пост: https://www.thechrisoshow.com/2009/02/16/using-guard-clauses-in-your-ruby-code/

.joins(:test_passages)
           .where(test_passages: { successful: true, user: @user })
Comment on lines 21 to 22
Beta Send feedback
   @max-underthesun
max-underthesun 16 days ago
вот эта часть повторяется в методах
можно вынести в отдельный метод или скоуп

def badges
    if @test_passage.successful
   @max-underthesun
max-underthesun 16 days ago
то что бейджи выдаются только после успешного прохождения - это логика даже не всего сервиса, а конкретного правила в этом сервисе (группы правил)
в любой момент могут появиться бейджи, которые выдаются и после неуспешного прохождения (какой-нибудь "За 10 неудачных попыток сдачи одного и того же теста", к примеру)
стоит эту проверку убрать в правила

.joins(:test_passages)
           .where(test_passages: { successful: true, user: @user })
           .distinct.length == badge.category.tests.length
    end
   @max-underthesun
max-underthesun 16 days ago
логика проверки в методах теперь похожа на правду
но тут есть еще один момент
если я правильно понимаю, то сейчас будет работать так:
если пройти все тесты категории и получить бейдж, а потом повторно проходить любой из тестов категории, то будешь каждый раз получать бейдж
надо сделать так, чтобы повторно бейдж выдавался за "повторное прохождение всех тестов категории"
   @max-underthesun
max-underthesun 16 days ago
аналогично с правилом по уровню

<div class="form-group">
    <%= form.label :rule_name %>
    <%= form.collection_select :rule_name, Badge.all, :id, :rule_name, {}, class: "form-control"  %>
   @max-underthesun
max-underthesun 16 days ago
здесь конечно нужно выводить во вьюхе не то, что хранится в таблице (имена правил), а какие-то "юзер френдли" строки
другими словами коллекцию в селект правильно будет реализовать с помощью хелпера и с использованием локализации - нужно замапить имена правил на ключи локализации и здесь использовать именно такую коллекцию

def all_test_from_category(badge)
   @max-underthesun
max-underthesun 15 days ago
ты убрал из метода badges проверку if @test_passage.successful, но не вижу, чтобы она была добавлена в правила
можно прописать ее в явном виде ранним выходом из метода (аналогично 17 строке, к примеру)

 def all_test_from_category(badge)
    return false unless badge.category == @test.category

     if @user.badges.where('users_badges.badge_id = ?', badge.id).length != 0
   @max-underthesun
max-underthesun 15 days ago
Suggested change 
    if @user.badges.where('users_badges.badge_id = ?', badge.id).length != 0
    if @user.badges.where(id: badge.id).exists?
Commit suggestion 
к соединительной таблице можно не обращаться, просто смотришь есть уже такие бейджи у пользователя или нет, если один и тот же бейдж может выдаваться многократно, то значит у пользователя может быть несколько бейджей с одинаковым ай-ди

про exists?: https://guides.rubyonrails.org/active_record_querying.html#existence-of-objects

if @user.badges.where('users_badges.badge_id = ?', badge.id).length != 0
      quantity_passages = @user.badges.where('users_badges.badge_id = ?', badge.id).count
      current_tests_category_passages = Test.tests_success(@user).where(tests: { category: badge.category }).group(:test_id).count.min.min
   @max-underthesun
max-underthesun 15 days ago
сложно написано и неявно
собираются объекты из таблицы tests, далее группировка идет по таблице tests_passages
работать будет, но по возможности нужно избегать таких неявных взаимодействий
из этого кода не видно откуда вдруг берется tests_passages

мне кажется эта проверка некорректная
группировка с count вернет хеш вида {1 => 3, 2 => 2}, где первая цифра - это ай-ди теста (по нему группируется), вторая цифра количество прохождений этого теста
как я понимаю замысел нужно найти минимальное значение количества прохождений, это 2 в данном примере (значение по второму ключу)
однако .min.min не вернет это значение:

2.6.0 :021 > {1 => 3, 2 => 2}.min.min
 => 1 
задачу лучше решать не через группировку
через группировку можно написать рабочее решение, но проще пойти другим путем
если идет проверка, к примеру "все тесты категории", то в ней можно посмотреть выдавались ли уже такие бейджи раньше
если выдавались, то взять последний по дате выдачи
и далее проверку проводить только по тем "прохождениям теста", которые по дате идут после выдачи этого бейджа

<div class="form-group">
    <%= form.label :rule_name %>
    <%= form.select :rule_name, Badge.all.collect {|badge| [friendly_name(badge.rule_name), badge.rule_name] }, {}, { class: "form-control" }  %>
   @max-underthesun
max-underthesun 15 days ago
как я и писал в предыдущем комментарии: #14 (comment)
нужно вынести формирование коллекции в хелпер
не надо здесь писать Badge.all.....
вызови здесь хелпер, который вернет готовую коллекцию

def all_test_from_category
    I18n.t('admin.badge.category')
  end

   def test_with_one_attempt
    I18n.t('admin.badge.one_attempt')
  end

   def all_test_with_level
    I18n.t('admin.badge.all_test_level')
  end
Comment on lines 6 to 16
Beta Send feedback
   @max-underthesun
max-underthesun 15 days ago
для каждого нового правила добавлять новый метод?
проще в 3 строке вызвать I18n.t("admin.badge.rules.#{name}")
и в локализации правильные ключи прописать, совпадающие с именами правил, хранящимися в модели
тогда эти три метода не нужны
и в общем-то метод friendly_name тоже не нужен
такой вызов можно прописать прямо в коде, который формирует коллекцию



